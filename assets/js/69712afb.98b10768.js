"use strict";(self.webpackChunkcrisptechy=self.webpackChunkcrisptechy||[]).push([[54],{3905:(e,r,t)=>{t.d(r,{Zo:()=>p,kt:()=>m});var n=t(7294);function o(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function a(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?a(Object(t),!0).forEach((function(r){o(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function s(e,r){if(null==e)return{};var t,n,o=function(e,r){if(null==e)return{};var t,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)t=a[n],r.indexOf(t)>=0||(o[t]=e[t]);return o}(e,r);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)t=a[n],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=n.createContext({}),l=function(e){var r=n.useContext(c),t=r;return e&&(t="function"==typeof e?e(r):i(i({},r),e)),t},p=function(e){var r=l(e.components);return n.createElement(c.Provider,{value:r},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var r=e.children;return n.createElement(n.Fragment,{},r)}},f=n.forwardRef((function(e,r){var t=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=l(t),f=o,m=u["".concat(c,".").concat(f)]||u[f]||d[f]||a;return t?n.createElement(m,i(i({ref:r},p),{},{components:t})):n.createElement(m,i({ref:r},p))}));function m(e,r){var t=arguments,o=r&&r.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=f;var s={};for(var c in r)hasOwnProperty.call(r,c)&&(s[c]=r[c]);s.originalType=e,s[u]="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=t[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,t)}f.displayName="MDXCreateElement"},1061:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var n=t(7462),o=(t(7294),t(3905));const a={},i=void 0,s={unversionedId:"dsaconcepts/Trees/IntuitiveBinaryTrees/SameTree",id:"dsaconcepts/Trees/IntuitiveBinaryTrees/SameTree",title:"SameTree",description:"class Solution {",source:"@site/docs/dsaconcepts/Trees/IntuitiveBinaryTrees/SameTree.md",sourceDirName:"dsaconcepts/Trees/IntuitiveBinaryTrees",slug:"/dsaconcepts/Trees/IntuitiveBinaryTrees/SameTree",permalink:"/crisptechy/docs/dsaconcepts/Trees/IntuitiveBinaryTrees/SameTree",draft:!1,editUrl:"https://github.com/pratikkumar399/crisptechy/tree/master/docs/dsaconcepts/Trees/IntuitiveBinaryTrees/SameTree.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"LowestCommonAncestors",permalink:"/crisptechy/docs/dsaconcepts/Trees/Ancestors/LowestCommonAncestors"},next:{title:"ZigZagTraversal",permalink:"/crisptechy/docs/dsaconcepts/Trees/Traversals/ZigZagTraversal"}},c={},l=[],p={toc:l},u="wrapper";function d(e){let{components:r,...t}=e;return(0,o.kt)(u,(0,n.Z)({},p,t,{components:r,mdxType:"MDXLayout"}),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Given the roots of two binary trees p and q, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Approach : Run preorder Traversals on the both the tree and store their result in a list and then compare the list(vector in cpp).\nAnother approach : traverse to the left and right of the tree and compare the values of the nodes. If at any point the values are not equal then return false. If the traversal is complete then return true.")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"We will proceed with the recursive approach.\\")),(0,o.kt)("p",null,"Code : "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(p==NULL && q==NULL) return true;\n        if(p==NULL || q==NULL) return false;\n        if(p->val!=q->val) return false;\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\n    }\n};\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Time complexity : O(n)\nSpace complexity : O(H), where H is the height of the tree")),(0,o.kt)("p",null,"Vector apporach : "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"\n    /**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> preorderTraversal(TreeNode* root ,vector<int> &ans) {\n        \n        pre(root,ans);\n        return ans ;\n    }\n    \n    void pre(TreeNode* root , vector<int> &ans){\n         if(root == NULL) {\n           ans.push_back(-1);\n           return;\n         }\n        ans.push_back(root->val);\n        pre(root->left,ans);\n        pre(root->right ,ans);\n      \n  }\n\n  \n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        vector<int> tree1 ,tree2;\n        preorderTraversal(p,tree1);\n        preorderTraversal(q,tree2);\n        if(tree1 == tree2) return true;\n        return false;        \n    }\n};\n")))}d.isMDXComponent=!0}}]);