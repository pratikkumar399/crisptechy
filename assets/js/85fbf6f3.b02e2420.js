"use strict";(self.webpackChunkcrisptechy=self.webpackChunkcrisptechy||[]).push([[8249],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>d});var r=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function a(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=r.createContext({}),c=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=c(e.components);return r.createElement(s.Provider,{value:n},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},h=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,u=a(e,["components","mdxType","originalType","parentName"]),p=c(t),h=i,d=p["".concat(s,".").concat(h)]||p[h]||m[h]||o;return t?r.createElement(d,l(l({ref:n},u),{},{components:t})):r.createElement(d,l({ref:n},u))}));function d(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,l=new Array(o);l[0]=h;var a={};for(var s in n)hasOwnProperty.call(n,s)&&(a[s]=n[s]);a.originalType=e,a[p]="string"==typeof e?e:i,l[1]=a;for(var c=2;c<o;c++)l[c]=t[c];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}h.displayName="MDXCreateElement"},6064:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var r=t(7462),i=(t(7294),t(3905));const o={},l=void 0,a={unversionedId:"DsaInteviewQuestions/Sort012",id:"DsaInteviewQuestions/Sort012",title:"Sort012",description:"Sort Colors",source:"@site/interviewseries/DsaInteviewQuestions/Sort012.md",sourceDirName:"DsaInteviewQuestions",slug:"/DsaInteviewQuestions/Sort012",permalink:"/crisptechy/interviewseries/DsaInteviewQuestions/Sort012",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"interviewSeries",previous:{title:"SetMatrixZero",permalink:"/crisptechy/interviewseries/DsaInteviewQuestions/SetMatrixZero"},next:{title:"UniquePaths",permalink:"/crisptechy/interviewseries/DsaInteviewQuestions/UniquePaths"}},s={},c=[{value:"Sort Colors",id:"sort-colors",level:2},{value:"Approach",id:"approach",level:3},{value:"Brute Force Approach",id:"brute-force-approach",level:3},{value:"Counting Sort",id:"counting-sort",level:3},{value:"Dutch National Flag Algorithm",id:"dutch-national-flag-algorithm",level:3}],u={toc:c},p="wrapper";function m(e){let{components:n,...o}=e;return(0,i.kt)(p,(0,r.Z)({},u,o,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"sort-colors"},"Sort Colors"),(0,i.kt)("p",null,"Problem link : ",(0,i.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/sort-colors/"},"Sort Colors")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Alt text",src:t(6414).Z,width:"917",height:"302"})),(0,i.kt)("p",null,"Lets talk about the approach to solve this problem."),(0,i.kt)("h3",{id:"approach"},"Approach"),(0,i.kt)("p",null,"1 . Brute force approach : In this approach we will simply sort the array and then we will return the sorted array."),(0,i.kt)("p",null,"2 . Counting Sort : In this approach we will count the number of 0's , 1's and 2's and then we will fill the array with 0's , 1's and 2's."),(0,i.kt)("p",null,"3 . Dutch National Flag Algorithm : In this approach we will use three pointers low , mid and high. low will point to the first element of the array , mid will point to the first element of the array and high will point to the last element of the array. We will iterate over the array and if we encounter 0 then we will swap it with the element at mid and we will increment both low and mid. If we encounter 1 then we will simply increment mid and if we encounter 2 then we will swap it with the element at high and we will decrement high."),(0,i.kt)("h3",{id:"brute-force-approach"},"Brute Force Approach"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"\nclass Solution {\n\npublic:\n\n    void sortColors(vector<int>& nums) {\n\n        // base case\n\n        if(nums.size() == 1){\n\n            return;\n\n        }\n\n        sort(nums.begin(),nums.end());\n\n    }\n\n};\n\n")),(0,i.kt)("h3",{id:"counting-sort"},"Counting Sort"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"\nclass Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n       if(nums.size() == 1){\n            return;\n        }\n        int count_0 = 0;\n        int count_1 = 0;\n        int count_2 = 0;\n\n        for(int i = 0 ; i < nums.size() ; i++){\n            if(nums[i] == 0){\n                count_0++;\n            }\n            else if(nums[i] == 1){\n                count_1++;\n            }\n            else{\n                count_2++;\n            }\n        }\n        // filling the array with 0's , 1's and 2's\n        for(int i = 0 ; i < nums.size() ; i++){\n            if(count_0 > 0){\n                nums[i] = 0;\n                count_0--;\n            }\n            else if(count_1 > 0){\n                nums[i] = 1;\n                count_1--;\n            }\n            else{\n                nums[i] = 2;\n                count_2--;\n            }\n        }\n    }\n};\n")),(0,i.kt)("h3",{id:"dutch-national-flag-algorithm"},"Dutch National Flag Algorithm"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"\nclass Solution {\n    public:\n    void sortColors(vector<int>& nums) {\n        if(nums.size() == 1){\n            return;\n        }\n        int low = 0;\n        int mid = 0;\n        int high = nums.size() - 1;\n        while(mid <= high){\n            // 0's will be filled in the beginning\n            if(nums[mid] == 0){\n                swap(nums[low],nums[mid]);\n                low++;\n                mid++;\n            }\n            // 1's will be filled in the middle\n            else if(nums[mid] == 1){\n                mid++;\n            }\n            // 2's will be filled from last\n            else{\n                swap(nums[mid],nums[high]);\n                high--;\n            }\n        }\n    }\n};\n")))}m.isMDXComponent=!0},6414:(e,n,t)=>{t.d(n,{Z:()=>r});const r=t.p+"assets/images/image-4-631037b038711788c77d5018fb3bd419.png"}}]);