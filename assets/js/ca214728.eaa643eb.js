"use strict";(self.webpackChunkcrisptechy=self.webpackChunkcrisptechy||[]).push([[150],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>h});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var o=a.createContext({}),c=function(e){var n=a.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(o.Provider,{value:n},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(t),u=i,h=d["".concat(o,".").concat(u)]||d[u]||m[u]||r;return t?a.createElement(h,s(s({ref:n},p),{},{components:t})):a.createElement(h,s({ref:n},p))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,s=new Array(r);s[0]=u;var l={};for(var o in n)hasOwnProperty.call(n,o)&&(l[o]=n[o]);l.originalType=e,l[d]="string"==typeof e?e:i,s[1]=l;for(var c=2;c<r;c++)s[c]=t[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},3425:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var a=t(7462),i=(t(7294),t(3905));const r={},s="OOPS in C++",l={unversionedId:"OOPS/OOPS_IN_CPP",id:"OOPS/OOPS_IN_CPP",title:"OOPS in C++",description:"Hello everyone, and welcome to this blog post. Today, we will discuss Object-Oriented Programming (OOP) in C++. This article will provide a brief overview of the essential concepts in OOP in C++.",source:"@site/docs/OOPS/OOPS_IN_CPP.md",sourceDirName:"OOPS",slug:"/OOPS/OOPS_IN_CPP",permalink:"/crisptechy/docs/OOPS/OOPS_IN_CPP",draft:!1,editUrl:"https://github.com/pratikkumar399/crisptechy/tree/master/docs/OOPS/OOPS_IN_CPP.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"OOPS",permalink:"/crisptechy/docs/category/oops"},next:{title:"OOPS in C++",permalink:"/crisptechy/docs/OOPS/OOPS_IN_CPP"}},o={},c=[{value:"Introduction to OOP",id:"introduction-to-oop",level:2},{value:"Class and Object Example",id:"class-and-object-example",level:2},{value:"Encapsulation",id:"encapsulation",level:2},{value:"Abstraction",id:"abstraction",level:2},{value:"Inheritance",id:"inheritance",level:2},{value:"Polymorphism",id:"polymorphism",level:2},{value:"Run-time Polymorphism (Virtual Functions)",id:"run-time-polymorphism-virtual-functions",level:3},{value:"Compile-time Polymorphism (Function Overloading)",id:"compile-time-polymorphism-function-overloading",level:3}],p={toc:c},d="wrapper";function m(e){let{components:n,...t}=e;return(0,i.kt)(d,(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"oops-in-c"},"OOPS in C++"),(0,i.kt)("p",null,"Hello everyone, and welcome to this blog post. Today, we will discuss Object-Oriented Programming (OOP) in C++. This article will provide a brief overview of the essential concepts in OOP in C++."),(0,i.kt)("h2",{id:"introduction-to-oop"},"Introduction to OOP"),(0,i.kt)("p",null,"Object-Oriented Programming is all about objects. In C++, unlike in C, we can use OOP to create objects that encapsulate both data members and functions into a single entity. Let's dive into the key terms in C++ OOP:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Class"),': A class is a fundamental building block in OOP. It contains both data members and functions. For example, a class "Car" may have properties like color and weight, as well as methods like drive and brake.')),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Objects"),": An object is an instance of a class. Each object has its own set of data members and can access the class's methods. For instance, a Mercedes, an Audi, and a Nano could be objects of the Car class.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Encapsulation"),": Encapsulation is the concept of bundling data members and methods within a class, hiding sensitive information and exposing only what is necessary. Access specifiers (public, private, protected) control the accessibility of class members.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Abstraction"),": Abstraction involves hiding complex implementation details and providing a simplified interface for users. It allows users to focus on the essential features of an object or system. Private access modifiers are used to achieve data abstraction or data hiding.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Inheritance"),": Inheritance allows a class to inherit properties and characteristics from another class. It promotes code reuse and establishes a parent-child relationship between classes. The child class (derived class) inherits features from the parent class (base class).")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Polymorphism"),": Polymorphism refers to the ability of a function or method to take different forms depending on the context. There are two types of polymorphism in C++: compile-time polymorphism (function overloading) and runtime polymorphism (function overriding)."))),(0,i.kt)("p",null,"In the upcoming sections, we will delve deeper into each of these topics, providing code snippets and examples to enhance understanding."),(0,i.kt)("h2",{id:"class-and-object-example"},"Class and Object Example"),(0,i.kt)("p",null,"Let's begin with a code snippet illustrating a class and an object in C++:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\nusing namespace std;\n\nclass Car {\n   private:\n    int color;\n    int weight;\n\n   public:\n    void drive() {\n        cout << "Drive the car" << endl;\n    }\n\n    void brake() {\n        cout << "Stop the car" << endl;\n    }\n};\n\nint main() {\n    Car obj1;\n    obj1.drive();\n    obj1.brake();\n    return 0;\n}\n\n')),(0,i.kt)("h2",{id:"encapsulation"},"Encapsulation"),(0,i.kt)("p",null,"To understand the concept of encapsulation, let's first understand access specifiers."),(0,i.kt)("p",null,"Access modifiers help us decide how the member functions can be accessed outside the class. In C++, there are three access modifiers:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Private"),": Data members declared as private cannot be accessed outside the class.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Private {\nprivate:\n    int x;\n    void show();\n};\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Public"),": Data members declared as public can be accessed outside the class.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Public {\npublic:\n    int x;\n    void show();\n};\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Protected"),": Data members declared as protected can only be accessed inside the inherited classes.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Protected {\nprotected:\n    int x;\n    void display();\n};\n")),(0,i.kt)("p",null,"In C++, the data members of a class are public by default."),(0,i.kt)("p",null,"Now, let's discuss what encapsulation actually means. Encapsulation is the practice of hiding sensitive information. It can be defined as an entity that binds data members and methods into a single unit. This further helps us achieve data abstraction or data hiding."),(0,i.kt)("h2",{id:"abstraction"},"Abstraction"),(0,i.kt)("p",null,"Abstraction means hiding the sensitive information and showing only the essential information to the user or the outside world. With abstraction, only important information is visible, while all the background details are hidden."),(0,i.kt)("p",null,"We can use the private access modifier in a class to hide important information. Therefore, we can decide which data members will be visible to the outside world and which ones will not."),(0,i.kt)("h2",{id:"inheritance"},"Inheritance"),(0,i.kt)("p",null,"Inheritance is a concept in object-oriented programming (OOP) that allows us to share properties and characteristics of one class in another. It eliminates the need to create another class with the same set of variables and methods. The class that inherits from another class is known as the child class or derived class, while the class from which the properties are being inherited is known as the parent class or base class. Inheritance allows us to reuse the existing class instead of creating a new one."),(0,i.kt)("p",null,"Here's an example of inheritance in C++:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n\nusing namespace std;\n\nclass Vehicle {\npublic:\n    Vehicle() {\n        cout << "This is a vehicle." << endl;\n    }\n};\n\nclass Car : public Vehicle {\npublic:\n    Car() {\n        cout << "This is a car." << endl;\n    }\n};\n\nint main() {\n    Car obj;\n    return 0;\n}\n')),(0,i.kt)("p",null,"In the above code, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Car")," class inherits from the ",(0,i.kt)("inlineCode",{parentName:"p"},"Vehicle")," class using the ",(0,i.kt)("inlineCode",{parentName:"p"},"public")," visibility mode. The ",(0,i.kt)("inlineCode",{parentName:"p"},"public")," visibility mode means that all the public members of the base class become public members of the child class. In this case, the output will be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"This is a vehicle.\nThis is a car.\n")),(0,i.kt)("p",null,"Please note that the private members of the base class are never inherited."),(0,i.kt)("p",null,"Note: Use a colon (",(0,i.kt)("inlineCode",{parentName:"p"},":"),") to inherit a class."),(0,i.kt)("p",null,"When discussing abstraction and encapsulation, we mentioned data hiding. Inheritance plays a significant role in achieving this."),(0,i.kt)("p",null,"In the code example above, after the colon, we simply write the name of the base class from which we want to inherit. Inheritance in C++ has a concept called visibility mode. This means we can inherit classes publicly or privately. By default, the visibility mode is private."),(0,i.kt)("p",null,"Consider the following code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'class Car : public Vehicle\n{\npublic:\n    Car()\n    {\n        cout << "This is a car" << endl;\n    }\n};\n')),(0,i.kt)("p",null,"In the above code, notice the use of the ",(0,i.kt)("inlineCode",{parentName:"p"},"public")," keyword after the colon. This is the visibility mode and it determines how we inherit our classes. If we inherit in the public mode, all the public members of the base class become public members of the child class. In the case of private mode, all the public members of the base class become private in the child class. In this case, objects of the derived class cannot access the members of the base class. It's important to remember that private members of the base class are never inherited."),(0,i.kt)("p",null,"Inheritance is further divided into five types:"),(0,i.kt)("p",null,"a) Single Inheritance: There is only one derived class derived from the base class.\nb) Multiple Inheritance: Deriving a single class from multiple base classes is called multiple inheritance.\nc) Hierarchical Inheritance: Multiple classes are derived from a single base class.\nd) Multilevel Inheritance: One class derived from another class results in multilevel inheritance.\ne) Hybrid Inheritance: It refers to a combination of multiple types of inheritance under one roof."),(0,i.kt)("h2",{id:"polymorphism"},"Polymorphism"),(0,i.kt)("p",null,"Polymorphism is an essential concept in OOP. It allows a function or method to have different forms depending on the type of object it is invoked with. Similar to how a cricket coach can be a father to someone, a husband to someone else, and a brother to another person, polymorphism allows methods to have different forms based on the calls they receive."),(0,i.kt)("p",null,"In C++, there are two types of polymorphism:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Run-time Polymorphism: In run-time polymorphism, the methods to be executed are decided at runtime. If the number of arguments passed and the method name is the same, the appropriate method is determined at runtime.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Compile-time Polymorphism: In compile-time polymorphism, the methods are invoked depending on the number of parameters. The function that matches the call is the one that runs during compile time."))),(0,i.kt)("h3",{id:"run-time-polymorphism-virtual-functions"},"Run-time Polymorphism (Virtual Functions)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n\nclass Shape {\npublic:\n    virtual void draw() {\n        std::cout << "Drawing a shape." << std::endl;\n    }\n};\n\nclass Circle : public Shape {\npublic:\n    void draw() override {\n        std::cout << "Drawing a circle." << std::endl;\n    }\n};\n\nclass Rectangle : public Shape {\npublic:\n    void draw() override {\n        std::cout << "Drawing a rectangle." << std::endl;\n    }\n};\n\nint main() {\n    Shape* shape1 = new Circle();\n    Shape* shape2 = new Rectangle();\n\n    shape1->draw(); // Calls draw() method of Circle class\n    shape2->draw(); // Calls draw() method of Rectangle class\n\n    delete shape1;\n    delete shape2;\n\n    return 0;\n}\n')),(0,i.kt)("p",null,"In the above code, we define a base class ",(0,i.kt)("inlineCode",{parentName:"p"},"Shape")," and two derived classes ",(0,i.kt)("inlineCode",{parentName:"p"},"Circle")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Rectangle"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"Shape")," class has a virtual method ",(0,i.kt)("inlineCode",{parentName:"p"},"draw()"),". In the ",(0,i.kt)("inlineCode",{parentName:"p"},"main()")," function, we create pointers of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Shape")," and assign objects of derived classes to them. When we call the ",(0,i.kt)("inlineCode",{parentName:"p"},"draw()")," method using these pointers, the appropriate method based on the actual object type is called. This is run-time polymorphism as the decision on which method to invoke is made at runtime based on the object's type."),(0,i.kt)("h3",{id:"compile-time-polymorphism-function-overloading"},"Compile-time Polymorphism (Function Overloading)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n\nint add(int a, int b) {\n    return a + b;\n}\n\ndouble add(double a, double b) {\n    return a + b;\n}\n\nint main() {\n    int result1 = add(3, 4);           // Calls the first add() function\n    double result2 = add(2.5, 3.7);    // Calls the second add() function\n\n    std::cout << "Result 1: " << result1 << std::endl;\n    std::cout << "Result 2: " << result2 << std::endl;\n\n    return 0;\n}\n')),(0,i.kt)("p",null,"In the above code, we have two functions named ",(0,i.kt)("inlineCode",{parentName:"p"},"add()")," with different parameter types. One takes two integers as arguments, and the other takes two doubles. When we call the ",(0,i.kt)("inlineCode",{parentName:"p"},"add()")," function with different argument types, the appropriate function is selected at compile time based on the argument types. This is compile-time polymorphism as the decision on which function to call is made during the compilation process."),(0,i.kt)("blockquote",null,(0,i.kt)("h2",{parentName:"blockquote",id:"lets-explore-some-more-important-concepts-of-oops"},(0,i.kt)("strong",{parentName:"h2"},"Lets explore some more important concepts of OOPS:"))),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"this"),": It is a pointer that refers to the current instance of a class. It is used to access the members of the class within its member functions.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'class Person {\npublic:\n    void printName() {\n        cout << "Name: " << this->name << endl;\n    }\nprivate:\n    string name;\n};\n')),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"const"),": It is used to declare constants or to specify that a member function does not modify the object's state. ",(0,i.kt)("inlineCode",{parentName:"li"},"const")," objects cannot modify their member variables.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Circle {\npublic:\n    Circle(double radius) : radius(radius) {}\n    double getArea() const {\n        return 3.14159 * radius * radius;\n    }\nprivate:\n    const double radius;\n};\n")),(0,i.kt)("ol",{start:3},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"static"),": It is used to declare class-level variables or methods that are shared among all instances of the class. Static members can be accessed without creating an object of the class.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'class Counter {\npublic:\n    static int count;  // static member variable\n    static void increment() {\n        count++;\n    }\n};\n\nint Counter::count = 0;  // static member variable definition\n\nint main() {\n    Counter::increment();  // accessing static member function\n    cout << "Count: " << Counter::count << endl;  // accessing static member variable\n    return 0;\n}\n')),(0,i.kt)("ol",{start:4},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"friend"),": It is used to declare a function or class as a friend of another class. A friend function or class can access the private and protected members of the class.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'class Circle {\nprivate:\n    double radius;\npublic:\n    Circle(double r) : radius(r) {}\n    friend class Cylinder;  // Cylinder class is a friend of Circle\n};\n\nclass Cylinder {\npublic:\n    double getVolume(const Circle& circle) {\n        double height = 10.0;\n        return 3.14159 * circle.radius * circle.radius * height;\n    }\n};\n\nint main() {\n    Circle circle(5.0);\n    Cylinder cylinder;\n    cout << "Volume: " << cylinder.getVolume(circle) << endl;\n    return 0;\n}\n')),(0,i.kt)("ol",{start:5},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"virtual"),": It is used to declare a virtual function in the base class. Virtual functions can be overridden in derived classes, and the appropriate function is called based on the actual object type during run-time polymorphism.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'class Shape {\npublic:\n    virtual void draw() {\n        cout << "Drawing a shape." << endl;\n    }\n};\n\nclass Circle : public Shape {\npublic:\n    void draw() override {\n        cout << "Drawing a circle." << endl;\n    }\n};\n\nint main() {\n    Shape* shape = new Circle();\n    shape->draw();  // Calls the overridden function in the Circle class\n    delete shape;\n    return 0;\n}\n')),(0,i.kt)("ol",{start:6},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"override"),": It is used to explicitly indicate that a member function is intended to override a virtual function from the base class. It helps in preventing accidental errors and improves code readability.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'class Shape {\npublic:\n    virtual void draw() {\n        cout << "Drawing a shape." << endl;\n    }\n};\n\nclass Circle : public Shape {\npublic:\n    void draw() override {  // Explicitly marked as an override\n        cout << "Drawing a circle." << endl;\n    }\n};\n\nint main() {\n    Shape* shape = new Circle();\n    shape->draw();  // Calls the overridden function in the Circle class\n    delete shape;\n    return 0;\n}\n')),(0,i.kt)("ol",{start:7},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"constructor")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"destructor"),": Constructors are special member functions used for initializing objects of a class."),(0,i.kt)("p",{parentName:"li"},"They have the same name as the class and do not have a return type. Destructors are used to clean up the resources allocated by an object when it goes out of scope or is explicitly destroyed."))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'class Person {\npublic:\n    Person(const string& name) : name(name) {\n        cout << "Person constructor called." << endl;\n    }\n    ~Person() {\n        cout << "Person destructor called." << endl;\n    }\nprivate:\n    string name;\n};\n\nint main() {\n    Person person("Pratik");  // Constructor called\n    // ...\n    // Other code\n    // ...\n    return 0;  // Destructor called\n}\n')),(0,i.kt)("ol",{start:8},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"new")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"delete"),": These are operators used for dynamic memory allocation and deallocation, respectively. ",(0,i.kt)("inlineCode",{parentName:"li"},"new")," is used to allocate memory for an object on the heap, and ",(0,i.kt)("inlineCode",{parentName:"li"},"delete")," is used to deallocate the memory and destroy the object.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'class Rectangle {\npublic:\n    Rectangle(double w, double h) : width(w), height(h) {}\n    double calculateArea() {\n        return width * height;\n    }\n};\n\nint main() {\n    Rectangle* rect = new Rectangle(5.0, 10.0);  // Dynamic memory allocation\n    double area = rect->calculateArea();\n    cout << "Area: " << area << endl;\n    delete rect;  // Memory deallocation\n    return 0;\n}\n')))}m.isMDXComponent=!0}}]);