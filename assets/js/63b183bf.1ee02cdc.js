"use strict";(self.webpackChunkcrisptechy=self.webpackChunkcrisptechy||[]).push([[9860],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>h});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=r.createContext({}),u=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},l=function(e){var t=u(e.components);return r.createElement(p.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,p=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),c=u(n),d=i,h=c["".concat(p,".").concat(d)]||c[d]||m[d]||a;return n?r.createElement(h,o(o({ref:t},l),{},{components:n})):r.createElement(h,o({ref:t},l))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=d;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[c]="string"==typeof e?e:i,o[1]=s;for(var u=2;u<a;u++)o[u]=n[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3756:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>u});var r=n(7462),i=(n(7294),n(3905));const a={},o=void 0,s={unversionedId:"DsaInteviewQuestions/UniquePaths",id:"DsaInteviewQuestions/UniquePaths",title:"UniquePaths",description:"Unique Paths(62)",source:"@site/interviewseries/DsaInteviewQuestions/UniquePaths.md",sourceDirName:"DsaInteviewQuestions",slug:"/DsaInteviewQuestions/UniquePaths",permalink:"/crisptechy/interviewseries/DsaInteviewQuestions/UniquePaths",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"interviewSeries",previous:{title:"Sort012",permalink:"/crisptechy/interviewseries/DsaInteviewQuestions/Sort012"},next:{title:"BasicsOsQuestions",permalink:"/crisptechy/interviewseries/OperatingSystem/Basics/BasicsOsQuestions"}},p={},u=[{value:"Unique Paths(#62)",id:"unique-paths62",level:2},{value:"Tabulation Method",id:"tabulation-method",level:3},{value:"Optimized Tabulation Method",id:"optimized-tabulation-method",level:3}],l={toc:u},c="wrapper";function m(e){let{components:t,...a}=e;return(0,i.kt)(c,(0,r.Z)({},l,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"unique-paths62"},"Unique Paths(#62)"),(0,i.kt)("p",null,"Problem Link : ",(0,i.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/unique-paths/"},"Unique Paths")),(0,i.kt)("p",null,"Problem Statement : ",(0,i.kt)("inlineCode",{parentName:"p"},"A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there?")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Alt text",src:n(334).Z,width:"638",height:"538"})),(0,i.kt)("p",null,"Let's see what the question demands: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"We are required to move from top right corner to bottom left corner. And we have to find the unique paths to reach there. \n\nNow we can only move either down or right. So what we can do is that we can move down and right and then again down and right and so on and so forth. While doing this we have to make sure that we don't go out of the grid. And we keep the count of the unique paths.\n")),(0,i.kt)("p",null,"Brute force method: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"We can use recursion to solve this problem.\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n\n    int uniquePathsHelper(int m, int n){\n        if(m == 0 || n == 0){\n            return 1;\n        }\n        return uniquePathsHelper(m-1,n) + uniquePathsHelper(m,n-1);\n    }\n\n    int uniquePaths(int m, int n) {\n        return uniquePathsHelper(m -1,n-1);\n    }\n};\n")),(0,i.kt)("p",null,"Let's see the time and space complexity of this solution: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Time Complexity : O(2^(m+n)) -> Exponential\nSpace Complexity : O(m+n) -> Recursive stack\n")),(0,i.kt)("p",null,"Let's see how we can optimize this solution: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"We can see that we are calculating the same values again and again. So we can use memoization to store the values and use them again when required.\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n\n    int uniquePathsHelper(int m, int n, vector<vector<int>>& dp){\n        if(m == 0 || n == 0){\n            return 1;\n        }\n        if(dp[m][n] != -1){\n            return dp[m][n];\n        }\n        return dp[m][n] = uniquePathsHelper(m-1,n,dp) + uniquePathsHelper(m,n-1,dp);\n    }\n\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m+1,vector<int>(n+1,-1));\n        return uniquePathsHelper(m -1,n-1,dp);\n    }\n};\n")),(0,i.kt)("p",null,"Let's see the time and space complexity of this solution: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Time Complexity : O(m*n) -> not exponential anymore as we are storing the values in dp array and using them again. \nSpace Complexity : O(m*n) -> Recursive stack + dp array\n")),(0,i.kt)("h3",{id:"tabulation-method"},"Tabulation Method"),(0,i.kt)("p",null,"Let's see how we can optimize this solution further: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"\nclass Solution {\npublic:\n\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\n        dp[0][1] = 1;\n        for(int i = 1 ; i <= m ; i++){\n            for(int j = 1 ; j <= n ; j++){\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\n            }\n        }\n        return dp[m][n];\n    }\n};\n")),(0,i.kt)("p",null,"Let's see the time and space complexity of this solution: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Time Complexity : O(m*n) -> not exponential anymore as we are storing the values in dp array and using them again.\nSpace Complexity : O(m*n) -> dp array\n")),(0,i.kt)("h3",{id:"optimized-tabulation-method"},"Optimized Tabulation Method"),(0,i.kt)("p",null,"Let's see how we can optimize this solution further: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"\nclass Solution {\npublic:\n\n    int uniquePaths(int m, int n) {\n        vector<int> dp(n+1,0);\n        dp[1] = 1;\n        for(int i = 1 ; i <= m ; i++){\n            for(int j = 1 ; j <= n ; j++){\n                dp[j] = dp[j] + dp[j-1];\n            }\n        }\n        return dp[n];\n    }\n};\n")))}m.isMDXComponent=!0},334:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/image-13-8f3f11c1fbc24e1e495d6cd7fae3f2d4.png"}}]);