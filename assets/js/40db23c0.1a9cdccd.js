"use strict";(self.webpackChunkcrisptechy=self.webpackChunkcrisptechy||[]).push([[4686],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>m});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),p=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},l=function(e){var t=p(e.components);return r.createElement(c.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=p(n),h=a,m=u["".concat(c,".").concat(h)]||u[h]||d[h]||o;return n?r.createElement(m,i(i({ref:t},l),{},{components:n})):r.createElement(m,i({ref:t},l))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[u]="string"==typeof e?e:a,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},5265:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var r=n(7462),a=(n(7294),n(3905));const o={},i=void 0,s={unversionedId:"dsaconcepts/Graphs/bfsalgorithms",id:"dsaconcepts/Graphs/bfsalgorithms",title:"bfsalgorithms",description:"BFS Algorithm",source:"@site/docs/dsaconcepts/Graphs/bfsalgorithms.md",sourceDirName:"dsaconcepts/Graphs",slug:"/dsaconcepts/Graphs/bfsalgorithms",permalink:"/crisptechy/docs/dsaconcepts/Graphs/bfsalgorithms",draft:!1,editUrl:"https://github.com/pratikkumar399/crisptechy/tree/master/docs/dsaconcepts/Graphs/bfsalgorithms.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"KhansAlgorithm",permalink:"/crisptechy/docs/dsaconcepts/Graphs/KhansAlgorithm"},next:{title:"Bipartite Graph",permalink:"/crisptechy/docs/dsaconcepts/Graphs/bipartitegraph"}},c={},p=[{value:"BFS Algorithm",id:"bfs-algorithm",level:2}],l={toc:p},u="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,r.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"bfs-algorithm"},"BFS Algorithm"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"BFS is an algorithm for searching a graph data structure for a node that satisfies a given property. It starts at the tree root and explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.\n\nExtra memory, usually a queue, is needed to keep track of the child nodes that were encountered but not yet explored.\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Algorithm ")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Maintain a queue of vertices to be visited."),(0,a.kt)("li",{parentName:"ol"},"Create a visited vector to check if a vertex has been visited or not."),(0,a.kt)("li",{parentName:"ol"},"Pop the front of the vertex queue and check the adjacent nodes."),(0,a.kt)("li",{parentName:"ol"},"All the nodes in the bfs algo is visited exactly once."),(0,a.kt)("li",{parentName:"ol"},"If the node is not visited, mark it as visited and push it into the queue."),(0,a.kt)("li",{parentName:"ol"},"Repeat the process until the queue is empty."),(0,a.kt)("li",{parentName:"ol"},"If the queue is empty, then the bfs traversal is complete.")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Time Complexity : O(V+E) where V is number of vertices in the graph and E is number of edges in the graph.")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Space Complexity : O(V) where V is number of vertices in the graph.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'\n#include<bits/stdc++.h> \nusing namespace std ;\n\nclass Graph{\n \n  int V ;\n  vector<vector<int>> adj;\n  public : \n  Graph(int V) ; // constructor\n  // function to add an edge to the graph\n  void addEdge(int v , int u) ; \n  // function to do bfs traversal from a given source\n  void bfs(int source) ;\n\n};\n\nGraph::Graph(int V){\n    this->V = V ;\n    adj.resize(V) ;\n}\nvoid Graph::addEdge(int v, int u)\n{\n    adj[v].push_back(u);\n    adj[u].push_back(v);\n}\n\nvoid Graph::bfs(int source){\n    // mark all the vertices as not visited \n    vector<bool> visited(V , false) ;\n    // create a queue a bfs \n    queue<int> q ;\n    visited[source] = true ;\n    q.push(source) ;\n\n    while(!q.empty()){\n        // dequeue a vertex from queue\n        int u= q.front() ;\n        cout<<u<<" "<<endl ;\n        q.pop() ;\n        for(auto v : adj[u]){\n            if(!visited[v]){\n                visited[v] = true ;\n                q.push(v) ;\n            }\n        }\n    }\n\n\n}\n\nint main(){\n    int n, m;\n    cin >> n >> m;\n    // adjacency list for undirected graph\n    // time complexity: O(2E)\n\n    Graph g(n) ;\n    vector<int> adj[n];\n    for (int i = 0; i < m; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        g.addEdge(u , v) ;\n    }\n    int start ;\n    cin>> start ;\n\n    g.bfs(2) ;\n\n\n    return 0 ;\n}\n\n')))}d.isMDXComponent=!0}}]);