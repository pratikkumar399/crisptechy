"use strict";(self.webpackChunkcrisptechy=self.webpackChunkcrisptechy||[]).push([[2522],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>k});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var i=r.createContext({}),l=function(e){var t=r.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=l(e.components);return r.createElement(i.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,u=p(e,["components","mdxType","originalType","parentName"]),c=l(n),m=a,k=c["".concat(i,".").concat(m)]||c[m]||d[m]||o;return n?r.createElement(k,s(s({ref:t},u),{},{components:n})):r.createElement(k,s({ref:t},u))}));function k(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=m;var p={};for(var i in t)hasOwnProperty.call(t,i)&&(p[i]=t[i]);p.originalType=e,p[c]="string"==typeof e?e:a,s[1]=p;for(var l=2;l<o;l++)s[l]=n[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1514:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>p,toc:()=>l});var r=n(7462),a=(n(7294),n(3905));const o={},s="Bubble Sort",p={unversionedId:"dsaconcepts/Sorting/BubbleSort",id:"dsaconcepts/Sorting/BubbleSort",title:"Bubble Sort",description:"Credits: TeaMochi",source:"@site/docs/dsaconcepts/Sorting/BubbleSort.md",sourceDirName:"dsaconcepts/Sorting",slug:"/dsaconcepts/Sorting/BubbleSort",permalink:"/crisptechy/docs/dsaconcepts/Sorting/BubbleSort",draft:!1,editUrl:"https://github.com/pratikkumar399/crisptechy/tree/master/docs/dsaconcepts/Sorting/BubbleSort.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"topologicalsort",permalink:"/crisptechy/docs/dsaconcepts/Graphs/topologicalsort"},next:{title:"LowestCommonAncestors",permalink:"/crisptechy/docs/dsaconcepts/Trees/Ancestors/LowestCommonAncestors"}},i={},l=[{value:"Example to understand the complete process\ud83d\udc47\ud83c\udffb",id:"example-to-understand-the-complete-process",level:2},{value:"<ins>Round-1</ins>",id:"round-1",level:4},{value:"<u>Round-2 </u>",id:"round-2-",level:4},{value:"<u>Round-3</u>",id:"round-3",level:4},{value:"C++ Code for Bubble Sort demonstration",id:"c-code-for-bubble-sort-demonstration",level:2}],u={toc:l},c="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"bubble-sort"},"Bubble Sort"),(0,a.kt)("p",null,"Credits: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/TaeMochi12"},"TeaMochi")),(0,a.kt)("p",null,"It is a sorting algorithm which works by repeatedly swapping the adjacent elements if they are in wrong order or not in the required order."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"> It gets its name from the way the smaller element bubbles or moves to the top or the first position.\n\n> The element keeps getting swapped with the adjacent element until they are in the correct order.\n\n> It works for certain rounds everytime from the first position to get the fully sorted array at the end.\n")),(0,a.kt)("h2",{id:"example-to-understand-the-complete-process"},"Example to understand the complete process\ud83d\udc47\ud83c\udffb"),(0,a.kt)("p",null,"Suppose we have an array of numbers:"),(0,a.kt)("blockquote",null,(0,a.kt)("blockquote",{parentName:"blockquote"},(0,a.kt)("p",{parentName:"blockquote"},"[4,2,8,1,7]"))),(0,a.kt)("p",null,"Now for the array given above these will be the involved rounds of bubble sorting :"),(0,a.kt)("h4",{id:"round-1"},(0,a.kt)("ins",null,"Round-1")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Firstly it will compare 4 and 2 and swapping will be there as 4 is greater than 2."),(0,a.kt)("p",{parentName:"li"},"[",(0,a.kt)("strong",{parentName:"p"},"4"),",",(0,a.kt)("strong",{parentName:"p"},"2"),",8,1,7]"," -> ","[",(0,a.kt)("strong",{parentName:"p"},"2"),",",(0,a.kt)("strong",{parentName:"p"},"4"),",8,1,7]")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Now the second and third element i.e. 4 and 8 will be compared and no swapping will be there as 4 is smaller than 8."),(0,a.kt)("p",{parentName:"li"},"[2,",(0,a.kt)("strong",{parentName:"p"},"4"),",",(0,a.kt)("strong",{parentName:"p"},"8"),",1,7]"," -> ","[2,",(0,a.kt)("strong",{parentName:"p"},"4"),",",(0,a.kt)("strong",{parentName:"p"},"8"),",1,7]")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Now the next two elements i.e. 8 and 1 will be compared and both the elements will be swapped as 8 is greater than 1."),(0,a.kt)("p",{parentName:"li"},"[2,4,",(0,a.kt)("strong",{parentName:"p"},"8"),",",(0,a.kt)("strong",{parentName:"p"},"1"),",7]"," -> ","[2,4,",(0,a.kt)("strong",{parentName:"p"},"1"),",",(0,a.kt)("strong",{parentName:"p"},"8"),",7]")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Now the last two elements will be compared i.e. 8 and 7 and it is clear that they will be swapped as 8 is greater than 7."))),(0,a.kt)("p",null,"[2,4,1,",(0,a.kt)("strong",{parentName:"p"},"8"),",",(0,a.kt)("strong",{parentName:"p"},"7"),"]"," -> ","[2,4,1,",(0,a.kt)("strong",{parentName:"p"},"7"),",",(0,a.kt)("strong",{parentName:"p"},"8"),"]"),(0,a.kt)("p",null,"Here the first round is complete and the array which we get after it is:"),(0,a.kt)("blockquote",null,(0,a.kt)("blockquote",{parentName:"blockquote"},(0,a.kt)("p",{parentName:"blockquote"},"[2,4,1,7,8]"))),(0,a.kt)("p",null,"As we can see the array is not yet sorted so we will not stop here and go for another round."),(0,a.kt)("h4",{id:"round-2-"},(0,a.kt)("u",null,"Round-2 ")),(0,a.kt)("p",null," Now similar to  the first round we will again go with the complete swapping process starting from the first two elements."),(0,a.kt)("p",null," This round goes as:"),(0,a.kt)("p",null," ","[",(0,a.kt)("strong",{parentName:"p"},"2"),",",(0,a.kt)("strong",{parentName:"p"},"4"),",1,7,8]"," -> ","[",(0,a.kt)("strong",{parentName:"p"},"2"),",",(0,a.kt)("strong",{parentName:"p"},"4"),",1,7,8]"," (No swapping required)"),(0,a.kt)("p",null," ","[2,",(0,a.kt)("strong",{parentName:"p"},"4"),",",(0,a.kt)("strong",{parentName:"p"},"1"),",7,8]"," -> ","[2,",(0,a.kt)("strong",{parentName:"p"},"1"),",",(0,a.kt)("strong",{parentName:"p"},"4"),",7,8]"," "),(0,a.kt)("p",null," ","[2,1,",(0,a.kt)("strong",{parentName:"p"},"4"),",",(0,a.kt)("strong",{parentName:"p"},"7"),",8]"," -> ","[2,1,",(0,a.kt)("strong",{parentName:"p"},"4"),",",(0,a.kt)("strong",{parentName:"p"},"7"),",8]"," (No swapping required)"),(0,a.kt)("p",null," ","[2,1,4,",(0,a.kt)("strong",{parentName:"p"},"7"),",",(0,a.kt)("strong",{parentName:"p"},"8"),"]"," -> ","[2,1,4,",(0,a.kt)("strong",{parentName:"p"},"7"),",",(0,a.kt)("strong",{parentName:"p"},"8"),"]"," (No swapping required)"),(0,a.kt)("p",null," Here the second round is also complete and the array we get after the second round is:"),(0,a.kt)("blockquote",null,(0,a.kt)("blockquote",{parentName:"blockquote"},(0,a.kt)("p",{parentName:"blockquote"},"[2,1,4,7,8]"))),(0,a.kt)("p",null," As we can see the array is still not sorted so we will go for yet another round."),(0,a.kt)("h4",{id:"round-3"},(0,a.kt)("u",null,"Round-3")),(0,a.kt)("p",null," We will go with the same swapping process again starting with the first two elements for this round as well."),(0,a.kt)("p",null," The third round goes as:"),(0,a.kt)("p",null," ","[",(0,a.kt)("strong",{parentName:"p"},"2"),",",(0,a.kt)("strong",{parentName:"p"},"1"),",4,7,8]"," -> ","[",(0,a.kt)("strong",{parentName:"p"},"1"),",",(0,a.kt)("strong",{parentName:"p"},"2"),",4,7,8]"),(0,a.kt)("p",null," ","[1,",(0,a.kt)("strong",{parentName:"p"},"2"),",",(0,a.kt)("strong",{parentName:"p"},"4"),",7,8]"," -> ","[1,",(0,a.kt)("strong",{parentName:"p"},"2"),",",(0,a.kt)("strong",{parentName:"p"},"4"),",7,8]"," (No swapping required)"),(0,a.kt)("p",null," ","[1,2,",(0,a.kt)("strong",{parentName:"p"},"4"),",",(0,a.kt)("strong",{parentName:"p"},"7"),",8]"," -> ","[1,2,",(0,a.kt)("strong",{parentName:"p"},"4"),",",(0,a.kt)("strong",{parentName:"p"},"7"),",8]"," (No swapping required)"),(0,a.kt)("p",null," ","[1,2,4,",(0,a.kt)("strong",{parentName:"p"},"7"),",",(0,a.kt)("strong",{parentName:"p"},"8"),"]"," -> ","[1,2,4,",(0,a.kt)("strong",{parentName:"p"},"7"),",",(0,a.kt)("strong",{parentName:"p"},"8"),"]"," (No swapping required)"),(0,a.kt)("p",null," Here the third round is complete and the array we are getting after this round is:"),(0,a.kt)("blockquote",null,(0,a.kt)("blockquote",{parentName:"blockquote"},(0,a.kt)("p",{parentName:"blockquote"},"[1,2,4,7,8]"))),(0,a.kt)("p",null," It is clear that the array is completely sorted now \ud83d\udc4d\ud83c\udffb so this was our final round and there is no need of further rounds."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"\ud83d\udc46\ud83c\udffbThis way we got the sorted array using Bubble Sort Algorithm.\n")),(0,a.kt)("h2",{id:"c-code-for-bubble-sort-demonstration"},"C++ Code for Bubble Sort demonstration"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'//unoptimised code\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n   vector<int> arr = {6, 2, 9, 1, 7, 4};\n   int n = arr.size();\n   int i, j;\n   for (i = 0; i < n-1; i++) {\n       for (j = 0; j < n-i-1; j++) {\n           if (arr[j] > arr[j+1]) {\n              swap(arr[j],arr[j+1]);\n           }\n       }\n   }\n   cout << "Sorted array: ";\n   for (i = 0; i < n; i++) {\n       cout << arr[i] << " ";\n   }\n   cout << endl;\n   return 0;\n}\n\n//optimised code, in best case scenario it will have a TC O(n)\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n   vector <int> arr = {6, 2, 9, 1, 7, 4};\n   int n = arr.size();\n   int i, j;\n   bool swapped;\n   for (i = 0; i < n-1; i++) {\n       swapped = false;\n       for (j = 0; j < n-i-1; j++) {\n           if (arr[j] > arr[j+1]) {\n               swapped = true;\n              swap(arr[j],arr[j+1]);\n           }\n       }\n       if (swapped == false) {\n           break;\n       }\n   }\n   cout << "Sorted array: ";\n   for (i = 0; i < n; i++) {\n       cout << arr[i] << " ";\n   }\n   cout << endl;\n   return 0;\n}\n\n\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"### Number of rounds/Passes required-\n As we saw that we require certain no. of rounds for the complete sorting using bubble sort which means we have to pass through the whole array for a certain no. of times.\n So here is the code to know how we can know the no. of passes required for bubble sort:\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n   vector <int> arr = {4,2,8,1,7};\n   int n = arr.size();\n   int i, j;\n   int passes=0;\n   bool swapped;\n   for (i = 0; i < n-1; i++) {\n       passes++;\n       swapped = false;\n       for (j = 0; j < n-i-1; j++) {\n         // passes++; //we can do this with the above passes++ to get the total number of swaps.\n           if (arr[j] > arr[j+1]) {\n               swapped = true;\n              swap(arr[j],arr[j+1]);\n           }\n       }\n       if (swapped == false) {\n           break;\n       }\n   }\n   cout << "Sorted array: ";\n   for (i = 0; i < n; i++) {\n       cout << arr[i] << " ";\n   }\n   cout << endl;\n   cout<<passes<<endl;\n   return 0;\n}\n\n')))}d.isMDXComponent=!0}}]);