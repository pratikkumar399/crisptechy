"use strict";(self.webpackChunkcrisptechy=self.webpackChunkcrisptechy||[]).push([[2907],{3905:(e,r,t)=>{t.d(r,{Zo:()=>p,kt:()=>f});var n=t(7294);function o(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function s(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function a(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?s(Object(t),!0).forEach((function(r){o(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function l(e,r){if(null==e)return{};var t,n,o=function(e,r){if(null==e)return{};var t,n,o={},s=Object.keys(e);for(n=0;n<s.length;n++)t=s[n],r.indexOf(t)>=0||(o[t]=e[t]);return o}(e,r);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)t=s[n],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=n.createContext({}),i=function(e){var r=n.useContext(c),t=r;return e&&(t="function"==typeof e?e(r):a(a({},r),e)),t},p=function(e){var r=i(e.components);return n.createElement(c.Provider,{value:r},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var r=e.children;return n.createElement(n.Fragment,{},r)}},v=n.forwardRef((function(e,r){var t=e.components,o=e.mdxType,s=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=i(t),v=o,f=d["".concat(c,".").concat(v)]||d[v]||u[v]||s;return t?n.createElement(f,a(a({ref:r},p),{},{components:t})):n.createElement(f,a({ref:r},p))}));function f(e,r){var t=arguments,o=r&&r.mdxType;if("string"==typeof e||o){var s=t.length,a=new Array(s);a[0]=v;var l={};for(var c in r)hasOwnProperty.call(r,c)&&(l[c]=r[c]);l.originalType=e,l[d]="string"==typeof e?e:o,a[1]=l;for(var i=2;i<s;i++)a[i]=t[i];return n.createElement.apply(null,a)}return n.createElement.apply(null,t)}v.displayName="MDXCreateElement"},223:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>l,toc:()=>i});var n=t(7462),o=(t(7294),t(3905));const s={},a=void 0,l={unversionedId:"dsaconcepts/Trees/Traversals/postordertraversal",id:"dsaconcepts/Trees/Traversals/postordertraversal",title:"postordertraversal",description:"PostOrder Traversal",source:"@site/docs/dsaconcepts/Trees/Traversals/postordertraversal.md",sourceDirName:"dsaconcepts/Trees/Traversals",slug:"/dsaconcepts/Trees/Traversals/postordertraversal",permalink:"/crisptechy/docs/dsaconcepts/Trees/Traversals/postordertraversal",draft:!1,editUrl:"https://github.com/pratikkumar399/crisptechy/tree/master/docs/dsaconcepts/Trees/Traversals/postordertraversal.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"levelordertraversal",permalink:"/crisptechy/docs/dsaconcepts/Trees/Traversals/levelordertraversal"},next:{title:"preordertraversal",permalink:"/crisptechy/docs/dsaconcepts/Trees/Traversals/preordertraversal"}},c={},i=[{value:"PostOrder Traversal",id:"postorder-traversal",level:2}],p={toc:i},d="wrapper";function u(e){let{components:r,...t}=e;return(0,o.kt)(d,(0,n.Z)({},p,t,{components:r,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"postorder-traversal"},"PostOrder Traversal"),(0,o.kt)("p",null,"Recursive Code for it: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"class Tree{\n    public:\n    vector<int> postOrderTraversal(TreeNode* root) {\n        vector<int> list;\n        dfs(root,list);\n        return list;\n    }\n\n    private:\n    void dfs(TreeNode* root, vector<int> list){\n        if(root == NULL){\n            return;\n        }\n        dfs(root->left,list);\n        dfs(root->right,list);\n        list.push_back(root);\n    }   \n}\n")),(0,o.kt)("p",null,"Iterative Code for it: "),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Idea behind it : Similar to PreOrder Traversal, but we need to reverse the list at the end. We need to reverse the list because we are pushing the elements in the order of root->right->left, so we need to reverse it to get the order of left->right->root.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"class Tree {\npublic:\n    vector<int> postorderTraversal(TreeNode* root) {\n        vector<int> tree;\n        if(root==NULL)return tree;\n        stack<TreeNode*> st;\n        st.push(root);\n        while(!st.empty()){\n            root=st.top();\n            st.pop();\n            tree.push_back(root->val);\n            if(root->left != NULL)st.push(root->left);\n            if(root->right != NULL)st.push(root->right);\n        }\n        reverse(tree.begin(),tree.end());\n        return tree;\n    }\n};\n")),(0,o.kt)("p",null,"Another iterative approach using one stack : "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"class Tree {\npublic:\n    vector<int> postorderTraversal(TreeNode* root) {\n        if(root == nullptr) return {};\n\n        stack<TreeNode*> st;\n        TreeNode *prevNode = nullptr;\n        // the idea is that we will keep track of the previously visited node \n        // whether the right child has already been visited or not\n\n        vector<int> res;\n        while(root != nullptr || !st.empty()) {\n            // lets go to the leftmost node\n            while(root != nullptr) {\n                st.push(root);\n                root = root->left;\n            }\n            // now we are at the leftmost node\n            TreeNode *currNode = st.top();\n            // if the right child is null or the right child has already been visited that means we can visit the current node. \n            if(currNode->right == nullptr || currNode->right == prevNode) {\n                res.push_back(currNode->val);\n                st.pop();\n                prevNode = currNode;\n            } else {\n                root = currNode->right;\n            }\n        }\n    }\n};\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Time  Complexity : O(n) ")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Space Complexity : O(n)")))}u.isMDXComponent=!0}}]);