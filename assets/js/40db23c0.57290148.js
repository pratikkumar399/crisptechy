"use strict";(self.webpackChunkcrisptechy=self.webpackChunkcrisptechy||[]).push([[4686],{3905:(t,e,n)=>{n.d(e,{Zo:()=>u,kt:()=>f});var r=n(7294);function a(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?o(Object(n),!0).forEach((function(e){a(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function s(t,e){if(null==t)return{};var n,r,a=function(t,e){if(null==t)return{};var n,r,a={},o=Object.keys(t);for(r=0;r<o.length;r++)n=o[r],e.indexOf(n)>=0||(a[n]=t[n]);return a}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(r=0;r<o.length;r++)n=o[r],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(a[n]=t[n])}return a}var c=r.createContext({}),p=function(t){var e=r.useContext(c),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},u=function(t){var e=p(t.components);return r.createElement(c.Provider,{value:e},t.children)},d="mdxType",h={inlineCode:"code",wrapper:function(t){var e=t.children;return r.createElement(r.Fragment,{},e)}},l=r.forwardRef((function(t,e){var n=t.components,a=t.mdxType,o=t.originalType,c=t.parentName,u=s(t,["components","mdxType","originalType","parentName"]),d=p(n),l=a,f=d["".concat(c,".").concat(l)]||d[l]||h[l]||o;return n?r.createElement(f,i(i({ref:e},u),{},{components:n})):r.createElement(f,i({ref:e},u))}));function f(t,e){var n=arguments,a=e&&e.mdxType;if("string"==typeof t||a){var o=n.length,i=new Array(o);i[0]=l;var s={};for(var c in e)hasOwnProperty.call(e,c)&&(s[c]=e[c]);s.originalType=t,s[d]="string"==typeof t?t:a,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}l.displayName="MDXCreateElement"},5265:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var r=n(7462),a=(n(7294),n(3905));const o={},i=void 0,s={unversionedId:"dsaconcepts/Graphs/bfsalgorithms",id:"dsaconcepts/Graphs/bfsalgorithms",title:"bfsalgorithms",description:"BFS Algorithm",source:"@site/docs/dsaconcepts/Graphs/bfsalgorithms.md",sourceDirName:"dsaconcepts/Graphs",slug:"/dsaconcepts/Graphs/bfsalgorithms",permalink:"/crisptechy/docs/dsaconcepts/Graphs/bfsalgorithms",draft:!1,editUrl:"https://github.com/pratikkumar399/crisptechy/tree/master/docs/dsaconcepts/Graphs/bfsalgorithms.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"UnionFIndAlgorihtm",permalink:"/crisptechy/docs/dsaconcepts/Graphs/UnionFIndAlgorihtm"},next:{title:"Bipartite Graph",permalink:"/crisptechy/docs/dsaconcepts/Graphs/bipartitegraph"}},c={},p=[{value:"BFS Algorithm",id:"bfs-algorithm",level:2},{value:"Algorithm",id:"algorithm",level:3},{value:"Code",id:"code",level:3},{value:"Another version of Bfs",id:"another-version-of-bfs",level:3},{value:"Tracing the path of the bfs traversal",id:"tracing-the-path-of-the-bfs-traversal",level:3}],u={toc:p},d="wrapper";function h(t){let{components:e,...n}=t;return(0,a.kt)(d,(0,r.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"bfs-algorithm"},"BFS Algorithm"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"BFS is an algorithm for searching a graph data structure for a node that satisfies a given property. It starts at the tree root and explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.\n\nExtra memory, usually a queue, is needed to keep track of the child nodes that were encountered but not yet explored.\n")),(0,a.kt)("h3",{id:"algorithm"},"Algorithm"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Maintain a queue of vertices to be visited."),(0,a.kt)("li",{parentName:"ol"},"Create a visited vector to check if a vertex has been visited or not."),(0,a.kt)("li",{parentName:"ol"},"Pop the front of the vertex queue and check the adjacent nodes."),(0,a.kt)("li",{parentName:"ol"},"All the nodes in the bfs algo is visited exactly once."),(0,a.kt)("li",{parentName:"ol"},"If the node is not visited, mark it as visited and push it into the queue."),(0,a.kt)("li",{parentName:"ol"},"Repeat the process until the queue is empty."),(0,a.kt)("li",{parentName:"ol"},"If the queue is empty, then the bfs traversal is complete.")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Time Complexity : O(V+E) where V is number of vertices in the graph and E is number of edges in the graph.")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Space Complexity : O(V) where V is number of vertices in the graph.")),(0,a.kt)("h3",{id:"code"},"Code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'\n#include<bits/stdc++.h> \nusing namespace std ;\n\nclass Graph{\n \n  int V ;\n  vector<vector<int>> adj;\n  public : \n  Graph(int V) ; // constructor\n  // function to add an edge to the graph\n  void addEdge(int v , int u) ; \n  // function to do bfs traversal from a given source\n  void bfs(int source) ;\n\n};\n\nGraph::Graph(int V){\n    this->V = V ;\n    adj.resize(V) ;\n}\nvoid Graph::addEdge(int v, int u)\n{\n    adj[v].push_back(u);\n    adj[u].push_back(v);\n}\n\nvoid Graph::bfs(int source){\n    // mark all the vertices as not visited \n    vector<bool> visited(V , false) ;\n    // create a queue a bfs \n    queue<int> q ;\n    visited[source] = true ;\n    q.push(source) ;\n\n    while(!q.empty()){\n        // dequeue a vertex from queue\n        int u= q.front() ;\n        cout<<u<<" "<<endl ;\n        q.pop() ;\n        for(auto v : adj[u]){\n            if(!visited[v]){\n                visited[v] = true ;\n                q.push(v) ;\n            }\n        }\n    }\n}\n\nint main(){\n    int n, m;\n    cin >> n >> m;\n    // adjacency list for undirected graph\n    // time complexity: O(2E)\n\n    Graph g(n) ;\n    vector<int> adj[n];\n    for (int i = 0; i < m; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        g.addEdge(u , v) ;\n    }\n    // source vertex\n    int start ;\n    cin>> start ;\n\n    // bfs traversal from source\n    g.bfs(source) ;\n\n\n    return 0 ;\n}\n\n')),(0,a.kt)("h3",{id:"another-version-of-bfs"},"Another version of Bfs"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"\n    vector<int> bfs(vector<vector<int>>& graph, int start){\n        vector<int> visited(graph.size(), false); \n        vector<int> result; \n\n        queue<int> q; \n        visited[start] = true; \n        q.push(start); \n\n        while(!q.empty()){\n            int current = q.front(); \n            q.pop(); \n            result.push_back(current); \n\n            for(auto it: graph[current]) { \n                if(!visited[it]){\n                    visited[it] = true; \n                    q.push(it); \n                }\n            }\n        }\n        return result; \n    }\n\n")),(0,a.kt)("h3",{id:"tracing-the-path-of-the-bfs-traversal"},"Tracing the path of the bfs traversal"),(0,a.kt)("blockquote",null,(0,a.kt)("blockquote",{parentName:"blockquote"},(0,a.kt)("p",{parentName:"blockquote"},"Finding shortest path using bfs in undirected unweighted graph"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to add an edge to the graph (undirected).\nvoid addEdge(vector<vector<int>> &graph, int from, int to)\n{\n    graph[from].push_back({to});\n    graph[to].push_back({from}); // Add the reverse edge for an undirected graph.\n}\n\n// Function to perform BFS and return the previous nodes for path reconstruction.\nvector<int> bfs(const vector<vector<int>> &graph, int start)\n{\n    int n = graph.size();\n    vector<int> prev(n, -1);\n    vector<bool> visited(n, false);\n    queue<int> q;\n\n    q.push(start);\n    visited[start] = true;\n\n    while (!q.empty())\n    {\n        int node = q.front();\n        cout << node << "->";\n        q.pop();\n\n        for (auto edge : graph[node])\n        {\n            int to = edge;\n            if (!visited[to])\n            {\n                visited[to] = true;\n                prev[to] = node;\n                q.push(to);\n            }\n        }\n    }\n    cout << endl;\n\n    return prev;\n}\n\n// Function to reconstruct the path from start to end using the previous nodes.\nvector<int> reconstructPath(vector<int> &prev, int start, int end)\n{\n    vector<int> path;\n    for (auto at = end; at != -1; at = prev[at])\n    {\n        path.push_back(at);\n    }\n    reverse(path.begin(), path.end());\n\n    if (path[0] == start)\n    {\n        return path; // Path found\n    }\n\n    path.clear(); // No path found, return an empty vector.\n    return path;\n}\n\n// Function to format the path as a string.\nstring formatPath(vector<int> &path)\n{\n    string result;\n    for (int i = 0; i < path.size(); i++)\n    {\n        result += to_string(path[i]);\n        if (i < path.size() - 1)\n        {\n            result += " -> ";\n        }\n    }\n    return result;\n}\n\nint main()\n{\n    int n = 6; // Number of nodes in the graph\n    vector<vector<int>> graph(n);\n\n    // Add edges to the graph (undirected).\n    addEdge(graph, 0, 1);\n    addEdge(graph, 0, 2);\n    addEdge(graph, 1, 3);\n    addEdge(graph, 2, 4);\n    addEdge(graph, 3, 5);\n\n    int start = 0;\n    int end = 5;\n\n    vector<int> prev = bfs(graph, start);\n    vector<int> path = reconstructPath(prev, start, end);\n\n    string formattedPath = formatPath(path);\n    cout << "Path: " << formattedPath << endl;\n\n    return 0;\n}\n')))}h.isMDXComponent=!0}}]);