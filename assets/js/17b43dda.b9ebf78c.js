"use strict";(self.webpackChunkcrisptechy=self.webpackChunkcrisptechy||[]).push([[368],{3905:(t,e,n)=>{n.d(e,{Zo:()=>p,kt:()=>h});var r=n(7294);function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function a(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?a(Object(n),!0).forEach((function(e){o(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function c(t,e){if(null==t)return{};var n,r,o=function(t,e){if(null==t)return{};var n,r,o={},a=Object.keys(t);for(r=0;r<a.length;r++)n=a[r],e.indexOf(n)>=0||(o[n]=t[n]);return o}(t,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);for(r=0;r<a.length;r++)n=a[r],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(o[n]=t[n])}return o}var s=r.createContext({}),l=function(t){var e=r.useContext(s),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},p=function(t){var e=l(t.components);return r.createElement(s.Provider,{value:e},t.children)},d="mdxType",u={inlineCode:"code",wrapper:function(t){var e=t.children;return r.createElement(r.Fragment,{},e)}},f=r.forwardRef((function(t,e){var n=t.components,o=t.mdxType,a=t.originalType,s=t.parentName,p=c(t,["components","mdxType","originalType","parentName"]),d=l(n),f=o,h=d["".concat(s,".").concat(f)]||d[f]||u[f]||a;return n?r.createElement(h,i(i({ref:e},p),{},{components:n})):r.createElement(h,i({ref:e},p))}));function h(t,e){var n=arguments,o=e&&e.mdxType;if("string"==typeof t||o){var a=n.length,i=new Array(a);i[0]=f;var c={};for(var s in e)hasOwnProperty.call(e,s)&&(c[s]=e[s]);c.originalType=t,c[d]="string"==typeof t?t:o,i[1]=c;for(var l=2;l<a;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}f.displayName="MDXCreateElement"},6026:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>c,toc:()=>l});var r=n(7462),o=(n(7294),n(3905));const a={},i=void 0,c={unversionedId:"dsaconcepts/Graphs/topologicalsort",id:"dsaconcepts/Graphs/topologicalsort",title:"topologicalsort",description:"Topological Sort",source:"@site/docs/dsaconcepts/Graphs/topologicalsort.md",sourceDirName:"dsaconcepts/Graphs",slug:"/dsaconcepts/Graphs/topologicalsort",permalink:"/crisptechy/docs/dsaconcepts/Graphs/topologicalsort",draft:!1,editUrl:"https://github.com/pratikkumar399/crisptechy/tree/master/docs/dsaconcepts/Graphs/topologicalsort.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"graphrepresentation",permalink:"/crisptechy/docs/dsaconcepts/Graphs/graphrepresentation"},next:{title:"LowestCommonAncestors",permalink:"/crisptechy/docs/dsaconcepts/Trees/Ancestors/LowestCommonAncestors"}},s={},l=[],p={toc:l},d="wrapper";function u(t){let{components:e,...n}=t;return(0,o.kt)(d,(0,r.Z)({},p,n,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Topological Sort")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Topological sort means linear ordering of the graph "),(0,o.kt)("li",{parentName:"ul"},"In this every node that occurs before a node in the graph must occur before its next node in the linear ordering of the graph ."),(0,o.kt)("li",{parentName:"ul"},"only valid for directed acyclic graphs"),(0,o.kt)("li",{parentName:"ul"},"if a graph contains cycle then if cannot have topological sort .")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"We will be using a dfs traversal to find the topological sort ")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"So the intuition is that after the completion of the dfs call for a node , when we backtrack we will add that node in the stack\nand this will make sure that the nodes are added in the linear order of their apprearance .")),(0,o.kt)("p",null,"Code for it \ud83d\udc4d"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution\n{\n    public:\n    \n    void topologicalSortDfs(int node , vector<int> &visited , vector<int> adj[] , stack<int> &st){\n        visited[node] = 1 ;\n        \n        for(auto it : adj[node]){\n            if(visited[it] == 0){\n                topologicalSortDfs(it,visited,adj,st) ;\n            }\n        }\n            st.push(node) ;\n        \n    }\n    \n    //Function to return list containing vertices in Topological order. \n    vector<int> topoSort(int V, vector<int> adj[]) \n    {\n        // code here\n        vector<int> visited(V, 0);\n        stack<int> st ;\n        \n        for(int i = 0 ; i<V ;i++){\n            if(!visited[i]){\n                topologicalSortDfs(i,visited,adj,st) ;\n            }\n        }\n        \n       vector<int> ans ;\n       while(!st.empty()){\n           int topo =  st.top() ;\n           st.pop() ;\n           ans.push_back(topo) ;\n           \n       }\n        return ans ;\n    }\n};\n\n")))}u.isMDXComponent=!0}}]);